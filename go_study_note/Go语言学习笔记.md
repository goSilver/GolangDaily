## Chapter 6 方法
### 6.1 定义
方法是与对象实例绑定的特殊函数。

方法是面向对象编程的基本概念，用于维护和展示对象自身的状态。对象是内敛的，每个实例都有各自不同的独立特征，以属性和方法来暴露对外通信接口。普通函数则专注于算法流程，通过接收参数来完成特定的逻辑运算，并返回最终结果。换句话说，方法是有关联状态的，而函数通常没有。

方法和函数定义语法区别在于前者有前置实例接收参数（receiver），编译器以此确定方法所属类型。

如何选择方法的receiver类型？

- 要修改实例状态，用 *T
- 无须修改状态的小对象或固定值，建议用 T
- 大对象建议用 *T，以减少复制成本
- 引用类型、字符串、函数等指针包装对象，直接用 T
- 若包含Mutex等同步字段，用 *T，避免因复制造成锁操作无效
- 其他无法确定等情况，都用 *T
### 6.1 匿名字段
可以像访问匿名字段成员那样调用其方法，由编译器负责查找。方法也会有同名遮蔽问题。但利用这种特性，可实现类似覆盖（override）操作。尽管能直接访问匿名字段但成员和方法，但他们依然不属于继承关系。
### 6.3 方法集
类型又一个与之相关但方法集合（method set），这决定来它是否实现某个接口。

- 类型 T 方法集合包含所有 receiver T 方法
- 类型 *T 方法集合包含所有 receiver T + *T 方法
- 匿名嵌入 S，T 方法集合包含所有 receiver S 方法
- 匿名嵌入 *S，T 方法集合包含所有 receiver S + *S 方法
- 匿名嵌入 S 或 *S，*T 方法集合包含所有 receiver S + *S 方法
## Chapter 7 接口
### 7.1 定义
接口代表一种调用契约，是多个方法声明但集合。

Go接口实现机制很简洁，只要目标类型方法集合内包含接口声明但全部方法，就被视为实现来接口，无须做显示声明。当然，目标类型也可以实现多个接口。
> 换句话说，我们可以先实现类型，而后再抽象出所需的接口。


从内部实现来看，接口自身也是一种结构类型，只是编译器会对其做出一下限制。

- 不能有字段
- 不能定义自己对方法
- 只能声明方法，不能实现
- 可嵌入其他接口类型
> 嵌入其他接口类型，相当于将其声明对方法集导入。这就要求不能有同名方法，因为不支持重载。还要，不能嵌入自身或循环嵌入，那会导致递归错误。

### 7.3 执行机制
接口使用来一个名为itab对结构存储运行期所需对相关类型信息。相关类型信息里保存里接口和实际对象对元数据。同时，itab还用fun数组（不定长结构）保存里实际方法地址，从而实现在运行期对目标方法对动态调用。
```go
type iface struct {
    tab  *itab
    data unsafe.Pointer
}

// layout of Itab known to compilers
// allocated in non-garbage-collected memory
// Needs to be in sync with
// ../cmd/compile/internal/gc/reflect.go:/^func.dumptabs.
type itab struct {
    inter *interfacetype
    _type *_type
    hash  uint32 // copy of _type.hash. Used for type switches.
    _     [4]byte
    fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.
}
```
接口还有一个重要特征：**将对象赋值给接口变量时，会复制该对象**。

我们无法修改接口存储对复制品，因为它也是unaddressable的。解决方法就是将对象指针赋值给接口，那么接口内存储的就是指针的复制品。
### 7.3 类型转换
类型推断可将接口变量还原为原始类型，或用来判断是否实现来某个更具体的接口类型。
### 7.4 技巧
让编译器检查，确保类型实现了指定接口。
```go
var _ openService.DataflowOpenAPI = (*DataflowOpenAPIImpl)(nil)
```
## Chapter 8 并发
### 8.1 并发的含义
并发和并行的区别：

- 并发：逻辑上具备同时处理多个任务的能力。
- 并行：物理上在同一时刻执行多个并发任务。

通俗点说就是，并发指的是在单核处理器上，多个任务以间隔交替的方式执行。而并行则依赖多核处理器等物理设备，让多个任务真正的在同一时刻执行。

关键字go并非执行并发操作，而是创建一个并发任务单元。

每个任务单元除保存函数指针、调用参数外，还会分配执行所需的栈空间。相比系统默认MB级别的线程栈，goroutine自定义栈初始化仅需2KB，所以才能创建成千山万的并发任务。
### 8.2 通道
允许全局变量、指针、引用类型这些非安全内存共享操作，就需要开发人员自行维护数据一致和完整性。Go鼓励使用CSP通道，**以通信来代替内存共享**，实现并发安全。

